"""Mission management routes."""

from datetime import datetime, timedelta
from typing import List, Optional

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload

from ..auth import get_current_user, permission_checker
from ..database import get_async_db
from ..models import Player, Mission, Location, Vehicle, MissionStatus
from ..schemas import MissionResponse, MissionCreate, MissionUpdate

router = APIRouter()


@router.get("/", response_model=List[MissionResponse])
async def get_available_missions(
    skip: int = 0,
    limit: int = 50,
    location_id: Optional[int] = None,
    mission_type: Optional[str] = None,
    min_reward: Optional[int] = None,
    max_difficulty: Optional[int] = None,
    db: AsyncSession = Depends(get_async_db),
    current_user: Player = Depends(get_current_user)
):
    """Get available missions."""
    query = select(Mission).where(Mission.status == MissionStatus.AVAILABLE)
    
    # Apply filters
    if location_id:
        query = query.where(Mission.origin_id == location_id)
    
    if mission_type:
        query = query.where(Mission.mission_type == mission_type)
    
    if min_reward:
        query = query.where(Mission.reward_credits >= min_reward)
    
    if max_difficulty:
        query = query.where(Mission.difficulty <= max_difficulty)
    
    # Filter by player level and requirements
    query = query.where(Mission.min_level <= current_user.level)
    query = query.where(Mission.required_reputation <= current_user.reputation)
    
    query = query.options(
        selectinload(Mission.origin),
        selectinload(Mission.destination)
    ).offset(skip).limit(limit)
    
    result = await db.execute(query)
    missions = result.scalars().all()
    
    return missions


@router.get("/my", response_model=List[MissionResponse])
async def get_my_missions(
    status_filter: Optional[str] = None,
    db: AsyncSession = Depends(get_async_db),
    current_user: Player = Depends(get_current_user)
):
    """Get current player's missions."""
    query = select(Mission).where(Mission.player_id == current_user.id)
    
    if status_filter:
        try:
            status_enum = MissionStatus(status_filter)
            query = query.where(Mission.status == status_enum)
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid status filter"
            )
    
    query = query.options(
        selectinload(Mission.origin),
        selectinload(Mission.destination)
    )
    
    result = await db.execute(query)
    missions = result.scalars().all()
    
    return missions


@router.post("/", response_model=MissionResponse)
async def create_mission(
    mission_data: MissionCreate,
    db: AsyncSession = Depends(get_async_db),
    current_user: Player = Depends(get_current_user)
):
    """Create a new mission (admin/system function)."""
    # In a real game, this might be restricted to admins or generated by the system
    
    # Verify locations exist
    origin_result = await db.execute(
        select(Location).where(Location.id == mission_data.origin_id)
    )
    origin = origin_result.scalar_one_or_none()
    
    destination_result = await db.execute(
        select(Location).where(Location.id == mission_data.destination_id)
    )
    destination = destination_result.scalar_one_or_none()
    
    if not origin or not destination:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Origin or destination location not found"
        )
    
    # Create mission
    new_mission = Mission(
        title=mission_data.title,
        description=mission_data.description,
        mission_type=mission_data.mission_type,
        origin_id=mission_data.origin_id,
        destination_id=mission_data.destination_id,
        required_cargo=mission_data.required_cargo,
        cargo_value=mission_data.cargo_value,
        difficulty=mission_data.difficulty,
        time_limit=mission_data.time_limit,
        reward_credits=mission_data.reward_credits,
        reward_experience=mission_data.reward_experience,
        penalty_credits=mission_data.penalty_credits,
        min_level=mission_data.min_level,
        required_vehicle_type=mission_data.required_vehicle_type,
        required_reputation=mission_data.required_reputation
    )
    
    # Set deadline if time limit is specified
    if mission_data.time_limit:
        new_mission.deadline = datetime.utcnow() + timedelta(minutes=mission_data.time_limit)
    
    db.add(new_mission)
    await db.commit()
    await db.refresh(new_mission)
    
    return new_mission


@router.get("/{mission_id}", response_model=MissionResponse)
async def get_mission(
    mission_id: int,
    db: AsyncSession = Depends(get_async_db)
):
    """Get specific mission details."""
    result = await db.execute(
        select(Mission)
        .options(
            selectinload(Mission.origin),
            selectinload(Mission.destination),
            selectinload(Mission.player)
        )
        .where(Mission.id == mission_id)
    )
    mission = result.scalar_one_or_none()
    
    if not mission:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Mission not found"
        )
    
    return mission


@router.post("/{mission_id}/accept", response_model=MissionResponse)
async def accept_mission(
    mission_id: int,
    vehicle_id: int,
    db: AsyncSession = Depends(get_async_db),
    current_user: Player = Depends(get_current_user)
):
    """Accept a mission."""
    # Get mission
    result = await db.execute(
        select(Mission).where(Mission.id == mission_id)
    )
    mission = result.scalar_one_or_none()
    
    if not mission:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Mission not found"
        )
    
    # Check if mission is available
    if mission.status != MissionStatus.AVAILABLE:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Mission is not available"
        )
    
    # Check if mission has expired
    if mission.deadline and mission.deadline < datetime.utcnow():
        mission.status = MissionStatus.EXPIRED
        await db.commit()
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Mission has expired"
        )
    
    # Check if player can accept mission
    if not permission_checker.can_accept_mission(current_user, mission):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You don't meet the requirements for this mission"
        )
    
    # Get and validate vehicle
    vehicle_result = await db.execute(
        select(Vehicle).where(
            Vehicle.id == vehicle_id,
            Vehicle.owner_id == current_user.id
        )
    )
    vehicle = vehicle_result.scalar_one_or_none()
    
    if not vehicle:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Vehicle not found or not owned by you"
        )
    
    # Check vehicle type requirement
    if mission.required_vehicle_type and vehicle.vehicle_type != mission.required_vehicle_type:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Mission requires {mission.required_vehicle_type.value} vehicle"
        )
    
    # Check if vehicle is at origin location
    if vehicle.current_location_id != mission.origin_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Vehicle must be at mission origin location"
        )
    
    # Accept mission
    mission.status = MissionStatus.ACCEPTED
    mission.player_id = current_user.id
    mission.accepted_at = datetime.utcnow()
    
    await db.commit()
    await db.refresh(mission)
    
    return mission


@router.post("/{mission_id}/start", response_model=MissionResponse)
async def start_mission(
    mission_id: int,
    db: AsyncSession = Depends(get_async_db),
    current_user: Player = Depends(get_current_user)
):
    """Start an accepted mission."""
    result = await db.execute(
        select(Mission).where(
            Mission.id == mission_id,
            Mission.player_id == current_user.id
        )
    )
    mission = result.scalar_one_or_none()
    
    if not mission:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Mission not found or not assigned to you"
        )
    
    if mission.status != MissionStatus.ACCEPTED:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Mission must be accepted before starting"
        )
    
    # Start mission
    mission.status = MissionStatus.IN_PROGRESS
    
    await db.commit()
    await db.refresh(mission)
    
    return mission


@router.post("/{mission_id}/complete", response_model=MissionResponse)
async def complete_mission(
    mission_id: int,
    db: AsyncSession = Depends(get_async_db),
    current_user: Player = Depends(get_current_user)
):
    """Complete a mission."""
    result = await db.execute(
        select(Mission).where(
            Mission.id == mission_id,
            Mission.player_id == current_user.id
        )
    )
    mission = result.scalar_one_or_none()
    
    if not mission:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Mission not found or not assigned to you"
        )
    
    if mission.status != MissionStatus.IN_PROGRESS:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Mission must be in progress to complete"
        )
    
    # Check if deadline has passed
    if mission.deadline and mission.deadline < datetime.utcnow():
        mission.status = MissionStatus.FAILED
        current_user.credits -= mission.penalty_credits
        await db.commit()
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Mission failed due to deadline"
        )
    
    # Complete mission
    mission.status = MissionStatus.COMPLETED
    mission.completed_at = datetime.utcnow()
    
    # Award rewards
    current_user.credits += mission.reward_credits
    current_user.experience += mission.reward_experience
    current_user.reputation += max(1, mission.difficulty)
    
    # Level up check
    experience_for_next_level = current_user.level * 1000
    if current_user.experience >= experience_for_next_level:
        current_user.level += 1
        current_user.experience -= experience_for_next_level
    
    await db.commit()
    await db.refresh(mission)
    
    return mission


@router.post("/{mission_id}/abandon", response_model=MissionResponse)
async def abandon_mission(
    mission_id: int,
    db: AsyncSession = Depends(get_async_db),
    current_user: Player = Depends(get_current_user)
):
    """Abandon a mission."""
    result = await db.execute(
        select(Mission).where(
            Mission.id == mission_id,
            Mission.player_id == current_user.id
        )
    )
    mission = result.scalar_one_or_none()
    
    if not mission:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Mission not found or not assigned to you"
        )
    
    if mission.status not in [MissionStatus.ACCEPTED, MissionStatus.IN_PROGRESS]:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Can only abandon accepted or in-progress missions"
        )
    
    # Abandon mission with penalty
    mission.status = MissionStatus.AVAILABLE
    mission.player_id = None
    mission.accepted_at = None
    
    # Apply penalty
    penalty = mission.penalty_credits or (mission.reward_credits // 4)
    current_user.credits = max(0, current_user.credits - penalty)
    current_user.reputation = max(0, current_user.reputation - 1)
    
    await db.commit()
    await db.refresh(mission)
    
    return mission
